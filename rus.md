# Познакомимся с наблюдателями за изменениями

По мере того, как вы разрабатываете более сложные и насыщенные JavaScript приложения
 — или свой собственный фреймворк — вы, скорее всего, сталкиваетесь с ситуацией,
 когда вам нужно знать, когда дерево DOM изменилось. Еще, может быть, вам хорошо
 было бы узнать, когда какой-либо вид загрузился или скрылся с экрана. Или,
 может быть, вы отлаживаете производительность приложения и хотиет измерить,
 сколько элементов в итоге меняются из-за DOM-операции.

Раньше мы делали это с помощью событий изменения. В спецификации DOM Level 2
интерфейс MutationEvent определял несколько событий: например, `DOMNodeInserted`
и `DOMAttrModified` — они вызываются браузером, когда был добавлен, изменен или
удален элемент. Однако в событиях об изменении DOM есть свои проблемы.

## Проблема с MutationEvents

Хотя в теории это замечательная идея, на практике у событий изменения есть две
большие проблемы.

  1. **`MutationEvent` вызывается синхронно.** События срабатывают тогда, когда
  они вызваны, и другие события в очереди могут из-за этого задержаться. Добавьте
  или удалите из документа достаточное количество элементов, и приложение начнет
  тормозить или зависнет.
  2. **`MutationEvent` — события, и поэтому были реализованы как события.** Я
  понимаю, что это звучит слишком очевидно, но подождите секунду. События проходят
  через DOM — они захватываются или всплывают. Оба этих процесса могут, в свою
  очередь, заставлять срабатывать другие обработчики событий, которые менют DOM.
  И, соответственно, те заставят сработать еще большее количество MutationEvents,
  отчего поток для исполнения JavaScript будет забит — а в худшем случае браузер рухнет.

Звучит жутко, не правда ли?

Действительно, с событиями изменения столько проблем, что они были помечены как
устаревшие в [спецификации DOM Level 3][1]. Но если события изменения устарели,
нам нужно что-то, что могло бы их заменить. Вот здесь и появляются наблюдатели
за изменениями (Mutation Observers).

##  Чем отличаются наблюдатели за изменениями?

Наблюдатели за изменениям определяются [стандартом DOM][2], и отличаются от
событий изменения следующим ключевым образом: они являются асинхронными. Они не
срабатывают каждый раз, как случается событие. Вместо этого они:

  * ждут, пока отрабатывают другие скрипты и задачи;
  * передают изменения не по одному, а блоками, в массиве записей изменений;
  * могут следить за всеми изменениями элемента, — или только за определенными типами изменений.

Более того, поскольку _это не события_, у наблюдателей нет высокой стоимости
имплементации, которая есть у событий. Наблюдателям гораздо сложнее подвесить
интерфейс или обрушить браузер.

Давайте посмотрим пример. В коде ниже мы прибавляем к фрагменту документа 2500
абзацев, а потом добавляем этот фрагмент в качестве дочернего к элементу `article`.

    var docFrag  = document.createDocumentFragment(),
        thismany = 2500,
        i=0,
        a = document.querySelector('article'),
        p;

    while ( i &lt; thismany) {
        // Создает новый элемент p, если он существует.
        // Если таковой существует, то клонируем существующий элемент.
        p = (p === undefined) ? document.createElement('p') : p.cloneNode(false);
        docFrag.appendChild(p);
        i%2B%2B;
    }

    a.appendChild( docFrag );


_Листинг 1: Добавление 2500 абзацев к документу через фрагмент документа._

Да, мы добавили 2500 абзацев, но мы сгруппировали их в одно обновление DOM,
используя фрагмент документа. И все же этот код генерирует 2500 событий
`DOMNodeInserted` — по одному на каждый абзац. Наш [обработчик события DOMNodeInserted][3]
вызывается 2500 раз. С другой стороны, если использовать наблюдатель за изменениями,
наш колбэк вызовется [только один раз][4]. Один наблюдатель за изменениями может
записывать несколько DOM-операций.

## Окей, а сейчас их можно использовать?

Поддержка доступна пока не везде. Интерфейс `MutationObserver` поддерживается в
Opera 15+, Firefox 14+ и Chrome 26+. Его также будет поддерживать Internet Explorer
11 и Safari 6.1. Safari 6.0 и Chrome 18—25 также поддерживают `MutationObserver`,
но с WebKit-префиксом (`WebKitMutationObserver`). Определить, поддерживается ли
наблюдение за изменениями, можно с помощью [следующего кода][5].

    var canObserveMutation = 'MutationObserver' in window;

_Листинг 2: Определяем, поддерживается ли браузером наблюдение за изменениями._

## Так, как же мне использовать `MutationObserver`?

Хорошие новости! Наблюдатели за изменениями очень легки в использовании. Сперва
вы создаете объект-наблюдатель с помощью конструктора `MutationObserver`, как в
[листинге 3][6]. В конструкторе вы указываете единственный параметр — функцию-колбэк.

    var observer, callback;
    callback = function( recordqueue ){
        // сделать что-то с каждой записью в массиве recordqueue.
    }
    observer = new MutationObserver( callback );

_Листинг 3: Создаем наблюдатель за изменениями._

Наша колбэк-функция получит в качестве аргумента массив объектов `MutationRecord`.
Каждый объект `MutationRecord` описывает изменение в дереве элементов. Мы обсудим
[записи изменений][7] подробнее позже.

Далее вам нужно будет определить, за каким элементом вы будете следить и какие
типы изменений в DOM вам интересны. Для этого мы используем метод `observe`.
Его первый параметр — элемент, а второй — [словарь][8] опций ([листинг 4][9]).
В примере ниже мы будем наблюдать за изменениями дочерних элементов или атрибутов
элемента `article`.

    var  options = {
        'childList': true,
        'attributes':true
    },
    article = document.querySelector( 'article' );

    observer.observe( article, options );

_Листинг 4: Решаем, какой элемент и тип изменения мы будем отслеживать_

Параметр `options` может включать следующие свойства и значения:

`childList`
    булево значение; наблюдать ли за изменениями за дочерними элементами этого элемента
`attributes`
    булево значение; наблюдать ли за изменениями в атрибутах этого элемента
`characterData`
    булево значение; наблюдать ли за изменениями данных или текстового содержания
    этого элемента
`subtree`
    булево значение; наблюдать ли за изменениями за всеми вложенными элементами
    этого элемента, включая дочерние элементы, их дочерние элементы и т.п.
`attributeOldValue`
    булево значение; если включено `attributes`, хотите ли вы захватить значение
    атрибута перед тем, как изменение будет записано.
`characterDataOldValue`
    булево значение; если включено `characterData`, хотите ли вы захватить значение
    данных перед тем, как изменение будет записано.
`attributeFilter`
    список атрибутов, за которыми нужно наблюдать, в квадратных скобках (пример: `['class','src']`);

Для того, чтобы следить за изменением, _необходимо_ включить значения `childList`,
`attributes` или `characterData`, и хотя бы одному из них должно быть присвоено
значение `true`.

Для того, чтобы перестать следить за изменениями, используйте метод `disconnect()`
(`observer.disconnect()`). После использования этого метода функция-колбэк больше
не будет вызываться. Метод `takeRecord` (`observer.takeRecord()`) очищает очередь
записей. Для того, чтобы продолжить следить за изменениями, просто снова вызовите
метод `observe`.

Я упомянул, что колбэк об изменении получает массив записей изменений в качестве
аргумента. Давайте посмотрим на то, что такое запись изменений.

## Записи изменений

Запись изменений — объект, который содержит информацию об одном изменении в дереве
документа. Объекты записи изменений соответствуют интерфейсу `MutationRecord` и
содержат следующие объекты.

`type`
    тип изменения: `attribute`, `characterData` или `childList`.
`target`
    элемент, в котором произошло изменение.
`addedNodes`
    список (NodeList) элементов, атрибутов и текстовых узлов, добавленных к дереву.
`removedNodes`
    список (NodeList) элементов, атрибутов и текстовых узлов, удаленных из дерева.
`previousSibling`
    возвращает предыдущий одноуровневый элемент или `null`, если такового нет.
`nextSibling`
    возвращает следующий одноуровневый элемент или `null`, если такового нет.
`attributeName`
    имя измененного атрибута или атрибутов. Если установлена опция `attributeFilter`,
    то вернутся только отфильтрованные атрибуты.
`oldValue`
    значение до изменения в случае изменения атрибута или `characterData`; `null`
    для изменения типа `childList`.

Теперь, когда мы рассмотрели синтаксис наблюдателей за изменениями и записей
изменений, давайте посмотрим на примеры.

## Наблюдение за добавлением и удалением дочерних элементов

Наблюдать за добавлением и удалением дочерних элементов довольно просто. Мы
создаем новый объект и передаем ему колбэк. Следить мы будем за `body` и
изменениями во всех его дочерних элементах. Пример в [листинге 5][10].

    var callback = function(allmutations){
        // allmutations — массив, и мы можем использовать соответствующие методы JavaScript.
        allmutations.map( functions(mr){
            var mt = 'Тип изменения: ' + mr.type;  // записываем тип изменения
            mt += 'Измененный элемент: ' + mr.target; // записываем измененный элемент.
            console.log( mt );
        });

    },
    mo = new MutationObserver(callback),
    options = {
        // обязательный параметр: наблюдаем за добавлением и удалением дочерних элементов.
        'childList': true,
        // наблюдаем за добавлением и удалением дочерних элементов любого уровня вложенности.
        'subtree': true
    }
    mo.observe(document.body, options);

_Листинг 5: Наблюдаем за добавлением и удалением дочерних элементов в документе._

Обратите внимание, что мы включили опцию `subtree` и установили ее как `true`.
Это значит, что наблюдатель будет получить информацию о том, когда к телу
документа [добавляются дочерние элементы][11] (например: `document.body.appendChild(el)`),
_а также_ когда они прибавляются к дочернему элементу документа
(`document.getElementById('my_element').appendChild(el)`). Если бы параметр
`subtree` был установлен в `false` или не был бы указан, то наблюдатель следил
бы только за элементами, добавляемыми непосредственно к телу документа.

Можно также наблюдать за изменениям в [фрагментах документа][12]. Просто передайте
фрагмент как первый параметр методу `observe`.

## Наблюдаем за изменениями атрибутов

Наблюдение за изменениями атрибутов работает во многом так же. Главная разница в
том, что к словарю опций вам нужно добавить `'attributes': true`. Если вы хотите
записывать предыдущее значение атрибута, то установите в `true` значение
`attributeOldValue`([посмотреть демо][13]).


    var callback = function(allmutations){
        // allmutations — массив, и мы можем использовать соответствующие методы JavaScript.
        allmutations.map( functions(mr){
            // записываем предыдущее значение атрибута.
            var attr = 'Предыдущее значение атрибута: ' + mr.oldValue;
            console.log(attr);
        });
    },
    element = document.getElementById('my_el'),
    mo = new MutationObserver(callback),
    options = {
        'attributes': true,        // обязательно
        'attributeOldValue': true  // перехватываем предыдущее значение атрибута.
    }

    mo.observe(element, options);

_Листинг 6: Наблюдаем за изменениями значений атрибутов._

Пример выше будет перехватывать все изменения любого атрибута нашего элемента,
включая и удаления. Как можно видеть [в демо][13], каждый раз, когда меняется
значение атрибута, к очереди добавляется новая запись изменения. Но что если
мы хотим наблюдать изменения только _определенных_ атрибутов?

### Фильтруем атрибуты, за которыми мы наблюдаем

Мы можем ограничить набор атрибутов, за которыми мы хотим наблюдать, добавив к
нашим опциям свойство `attributeFilter` ([листинг 7][14]). Значение
`attributeFilter` должно быть разделенным запятой списком атрибутов, за которыми
мы будем наблюдать (каждый атрибут должен быть в квадратных скобках).

    var options = {
        'attributes': true,
        'attributeOldValue': true,
        'attributeFilter': ['class'] // наблюдаем только за изменениями атрибута class
    }

    mo.observe(element, options);

_Листинг 7: Фильтруем атрибуты, за которыми мы наблюдаем._

Установка этого свойства означает, что запись изменения будет сгенерирована
_только_ для изменений значения атрибута `class` ([посмотреть демо][15]).

## Дополнительная информация

Чтобы узнать больше о наблюдателях за изменениями, обратите внимание на следующие
ресурсы:

* [Наблюдатели за изменениям на сайте WHATWG][16]
* [Наблюдатели за изменениями против событий изменения][17] — страница проекта Mutation Summary.
* [MutationReplacement][18], из вики W3C WebApps, — подробнее об историческом и техническом контексте.


   [1]: http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents
   [2]: http://dom.spec.whatwg.org/#mutation-observers
   [3]: http://dev.opera.com/mutationobserver-mutationevent.html
   [4]: http://dev.opera.com/mutationobserver-mutationobserver.html
   [5]: #detectMutationObserverSupport
   [6]: #MutationObserver
   [7]: #mutationrecords
   [8]: http://dev.w3.org/2006/webapi/WebIDL/#dfn-dictionary
   [9]: #usingobservefunction
   [10]: #watchchildnodes
   [11]: http://dev.opera.com/mutationobserver-addchildren.html
   [12]: http://dev.opera.com/mutationobserver-docfrag.html
   [13]: http://dev.opera.com/mutationobserver-attributes.html
   [14]: #filteringattributes
   [15]: http://dev.opera.com/mutationobserver-attributes-filtered.html
   [16]: http://dom.spec.whatwg.org/#mutation-observers
   [17]: http://code.google.com/p/mutation-summary/wiki/DOMMutationObservers
   [18]: http://www.w3.org/2008/webapps/wiki/MutationReplacement